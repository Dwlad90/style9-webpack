import postcss from 'postcss';
import type * as PostCSS from 'postcss';
import discardDuplicates from 'postcss-discard-duplicates';
import selectorParser from 'postcss-selector-parser';
import sortCSSmq from 'sort-css-media-queries';
import { PROPERTY_PRIORITY } from './constants';

const DEFAULT_PRIORITY = 1;

const PSEUDO_ORDER = [
  ':link',
  ':focus-within',
  ':first-child',
  ':last-child',
  ':odd-child',
  ':even-child',
  ':hover',
  ':focus',
  ':active',
  ':visited',
  ':disabled'
];

const EXCLUDE_RULE_TYPE = ['atrule'];

function getPriority(prop: string) {
  return PROPERTY_PRIORITY[prop] || DEFAULT_PRIORITY;
}

function isValidSelector({ nodes: [firstNode, ...restNodes] }: selectorParser.Root) {
  if (restNodes.length) return false;

  if (firstNode.nodes[0].type !== 'class') return false;

  for (let index = 1; index < firstNode.nodes.length; index++) {
    const node = firstNode.nodes[index];
    if (node.type !== 'pseudo') return false;
  }

  return true;
}

function parseSelector(selector: any) {
  return selectorParser(selector => selector).transformSync(selector);
}

function getPseudoClasses(selector: selectorParser.Container[]) {
  return selector
    .filter(selector => selector.type === 'pseudo' && selector.value[1] !== ':')
    .map(selector => selector.value);
}

const isPostCSSRoot = (node: any): node is PostCSS.Root => node.type === 'root';

function removeWithContext(rule: PostCSS.Declaration | PostCSS.Root) {
  let decl;
  let onlyChild = true;

  do {
    const { parent } = rule;
    if ('nodes' in rule && rule.nodes && rule.nodes.length) onlyChild = false;
    const clone = onlyChild ? rule.remove() : rule.clone();
    if (isPostCSSRoot(rule)) (clone as PostCSS.Root).removeAll();
    if (decl && 'append' in clone) clone.append(decl);
    decl = clone;
    rule = parent as PostCSS.Declaration | PostCSS.Root;
  } while (rule && !(isPostCSSRoot(rule)));

  return decl;
}

function getMediaQueries(rule: PostCSS.AtRule | PostCSS.Declaration | undefined): string[] {
  const mediaQueries: string[] = [];

  while (rule) {
    if (
      // Stryker disable next-line ConditionalExpression: extra test safety
      rule.type === 'atrule'
      && rule.name === 'media'
    ) {
      mediaQueries.push(rule.params);
    }
    rule = rule.parent as PostCSS.AtRule | PostCSS.Declaration;
  }

  return mediaQueries;
}

function getDecls(root: PostCSS.Root): PostCSS.Declaration[] {
  const decls: PostCSS.Declaration[] = [];

  root.walkDecls(rule => {
    decls.push(rule);
  });

  return decls;
}

function extractDecls(decls: PostCSS.Declaration[]) {
  const nodes: {
    decl: PostCSS.Root | PostCSS.Declaration;
    mediaQueries: string[];
    pseudoClasses: any;
  }[] = [];

  decls.forEach(rule => {
    if (EXCLUDE_RULE_TYPE.includes(rule.parent?.type || '$')) {
      return;
    }
    const selectors = parseSelector(rule.parent);
    const isStyle9Selector = isValidSelector(selectors);
    if (!isStyle9Selector) return;
    const pseudoClasses = getPseudoClasses(selectors.nodes[0] as any);
    const mediaQueries = getMediaQueries(rule.parent as PostCSS.AtRule | PostCSS.Declaration);
    const decl = removeWithContext(rule);
    const node = { decl, mediaQueries, pseudoClasses };
    nodes.push(node);
  });

  return nodes;
}

function sortNodes(nodes: {
  decl: PostCSS.Root | PostCSS.Declaration;
  mediaQueries: string[];
  pseudoClasses: any;
}[]) {
  nodes.sort((a, b) => {
    if (a.pseudoClasses.length !== b.pseudoClasses.length) {
      return a.pseudoClasses.length - b.pseudoClasses.length;
    }

    for (let index = 0; index < a.pseudoClasses.length; index++) {
      const clsA = a.pseudoClasses[index];
      const clsB = b.pseudoClasses[index];
      if (clsA !== clsB) {
        return PSEUDO_ORDER.indexOf(clsA) - PSEUDO_ORDER.indexOf(clsB);
      }
    }

    if (a.mediaQueries.length !== b.mediaQueries.length) {
      return a.mediaQueries.length - b.mediaQueries.length;
    }

    if (a.mediaQueries.length) {
      return sortCSSmq(
        a.mediaQueries.join(' and '),
        b.mediaQueries.join(' and ')
      );
    }

    const propA = (a.decl as any).nodes[0].prop;
    const propB = (b.decl as any).nodes[0].prop;

    return getPriority(propA) - getPriority(propB);
  });

  return nodes;
}

/**
 * Sort declarations first by pseudo-classes, then by media queries mobile
 * first, and finally by longhand prioerity
 * Only sort rules that are generated by style9, which should have a selector
 * that consists of a class and optionally of pseudo-elements & classes
 */
const sortPseudo: PostCSS.TransformCallback = (root) => {
  const decls = getDecls(root);
  const nodes = sortNodes(extractDecls(decls));

  nodes.forEach(({ decl }) => {
    root.append(decl);
  });
};

export default function processCSS(css: string | Buffer, options: PostCSS.ProcessOptions) {
  return postcss([discardDuplicates, sortPseudo]).process(css, options);
}
